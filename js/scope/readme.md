# 作用域

- 通过一句 var a = 1;了解JS的运行机制
 - 声明 + 赋值语句
 - a 变量存在哪里？内存中
 - 编译 var 变量声明的关键字
 - a 变量标识符 1

 - var a; // 编译阶段
   a = 1; // 执行阶段

   ## 变量相关
     - 作用域
        变量不会单独存在,属于一个作用域（编译阶段）
        作用域是变量的查找规则,在当前作用域查找变量,找不到,去父级作用域查找,一直冒泡 知道全局作用域, 为定义（执行阶段）

    ## var a= 1;  哪些东西要为它工作
      - JS 引擎  chrome v8 引擎 CEO
       负责整体工作
      - 编译器 CTO
       var a  =  1 分词
      - 作用域  COO 运营经理
       变量属于作用域
       作用域链

  - var a = 1;
   按编译和执行分为 var a; 变量属于定义时候作用域 词法作用域
   a = 1;查找 a 的过程 遵守作用域的规则 当前作用域->外层...->全局->没找到（停下俩） 找到了（立马停下来）

  - undefined
   未定义 js 数据类型之一
   js 弱类型语言，类型由值决定

  - var a = 1；
    引擎是如何领导编译器和作用域查找变量A的
     a = 1; 赋值操作 a 在等号的左边 LHS
     查找 分成LHS + RHS 左 右 
     a = b + 2

     a = 1 LHS
     a = b + 1
    - LHS 容器 赋值
    RHS   retrive his sourde value 取值
    console.log(a)

    - 作用域嵌套
      作用域链 
      当前作用域 -> 查找到全局的过程就是作用域链
      查找路径就是作用域链





    对代码 
    function foo(a) { 
    var b = a; 
     return a + b;
     }
   var c = foo( 2 ); 
   中 LHS 和 RHS 引用的分析
    LHS 引用（共 3 处）:

c = ...: 在 var c = foo( 2 ); 这行代码中，c 出现在赋值操作符 = 的左侧，因此它是一个 LHS 引用。 我们想要找到 c 的容器并将其赋值为 foo(2) 的返回值。 [1]
a = 2 (隐式变量分配): 当调用 foo(2) 时，会隐式地将参数 2 赋给函数的参数 a。 这个赋值操作也需要进行 LHS 查询来找到 a 的容器。 [2]
b = ...: 在函数 foo(a) 内部，var b = a; 这行代码中，b 出现在赋值操作符 = 的左侧，因此它是一个 LHS 引用。 我们想要找到 b 的容器并将其赋值为 a 的值。 [1]
RHS 引用（共 4 处）:

foo(2 ...): 在 var c = foo( 2 ); 这行代码中，我们需要获取 foo 的值（也就是函数本身）并执行它。 因此，foo 是一个 RHS 引用。 [3]
= a: 在 var b = a; 这行代码中，我们需要获取 a 的值并将其赋给 b。 因此，a 是一个 RHS 引用。 [3]
a ...: 在 return a + b; 这行代码中，我们需要获取 a 的值并将其与 b 的值相加。 因此，a 是一个 RHS 引用。 [3]
... b: 在 return a + b; 这行代码中，我们需要获取 b 的值并将其与 a 的值相加。 因此，b 是一个 RHS 引用。 [3]
总结
LHS 引用用于找到变量的容器并对其赋值，而 RHS 引用用于获取变量的值。 在分析代码时，区分 LHS 和 RHS 引用可以帮助我们更好地理解代码的执行过程以及作用域的查找规则。










